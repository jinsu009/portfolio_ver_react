JSON 파일을 불러올 때 **상대 경로(Relative Paths)**를 사용하는 것이 좋은 주된 이유는 프로젝트의 이식성(Portability)과 유지보수성을 높이고, 빌드 환경에 독립적이기 때문입니다.

1. 프로젝트의 이식성 및 유연성 (Portability)
   빌드 환경 독립성: 상대 경로는 현재 파일을 기준으로 목표 파일의 위치를 지정합니다. 따라서 프로젝트가 로컬 개발 환경에서 실행되든, 테스트 서버에서 실행되든, 또는 최종적으로 프로덕션 환경의 CDN(Content Delivery Network)에 배포되든, 파일 간의 상대적 위치만 유지되면 경로가 변경될 필요가 없습니다.

루트 경로 의존성 제거: 절대 경로(예: /data/my_info.json)를 사용하면 애플리케이션이 호스팅되는 루트 도메인이나 서브 디렉터리가 바뀌었을 때, 모든 경로를 일일이 수정해야 하는 문제가 발생합니다. 상대 경로는 이러한 환경 변화에 영향을 받지 않습니다.

2. 유지보수 및 리팩토링의 용이성
   파일 이동에 유연함: JSON 파일을 다른 폴더(예: assets에서 data로)로 이동하더라도, 파일을 불러오는 컴포넌트(Info.tsx)도 함께 이동한다면, 두 파일 간의 상대 경로는 변하지 않을 수 있습니다.

코드의 명확성: 개발자가 import 구문을 보았을 때, 현재 파일과 불러올 파일이 프로젝트 구조에서 얼마나 가까운지를 즉각적으로 파악할 수 있어 코드의 이해도를 높여줍니다. (예: ./는 가까움, ../../는 멀리 떨어져 있음)

3. 모듈 번들러와의 통합 (Webpack, Vite)
   번들링 최적화: React 프로젝트에서 import를 통해 JSON을 상대 경로로 불러오면, Webpack이나 Vite 같은 모듈 번들러가 해당 JSON 파일을 코드 종속성의 일부로 인식합니다.

이는 JSON 데이터가 최종 JavaScript 번들에 포함되어 비동기 로딩 없이 즉시 사용 가능하게 만듭니다.

데이터가 변경되면 번들러가 자동으로 재빌드를 수행하여 개발 편의성을 높입니다.

🚫 참고: 절대 경로의 사용처
프로젝트 내에서 절대 경로(@/data/my_info.json 또는 /src/data/my_info.json)를 사용하는 경우도 있지만, 이는 보통 **번들러 설정(Alias)**을 통해 프로젝트 루트를 기준으로 경로를 지정해 놓았을 때만 가능합니다. 이 경우에도 사실은 프로젝트 내부 경로를 간편하게 표현한 상대 경로의 변형으로 볼 수 있습니다.

요약하자면, 상대 경로는 React 컴포넌트와 데이터 파일 간의 관계를 단순하고 견고하게 유지하여, 복잡한 배포 환경 변화로부터 프로젝트를 보호하는 가장 실용적인 방법입니다.

---

아닙니다. React 프로젝트를 서버에 배포할 때도 **일반적으로 JSON 파일을 불러오는 데는 절대 경로보다 상대 경로 또는 Public 경로를 사용하는 것이 더 좋습니다.**

서버 배포 환경에서도 \*\*절대 경로(Absolute Path)\*\*를 사용하면 오히려 문제가 발생할 수 있습니다.

---

## 🚫 서버 배포 시 절대 경로를 피해야 하는 이유

React와 같은 프론트엔드 프로젝트를 빌드하고 배포할 때, "절대 경로"는 두 가지 의미로 해석될 수 있으며, 두 경우 모두 문제가 될 수 있습니다.

### 1\. 로컬 파일 시스템의 절대 경로 (Bad)

`C:\Users\User\Project\data\my_info.json`와 같은 로컬 컴퓨터의 절대 경로는 **절대 사용하면 안 됩니다.**

- **배포 환경에서 무효:** 서버(Linux, 클라우드 서버 등)에는 사용자의 로컬 파일 시스템이 존재하지 않기 때문에 이 경로는 무의미하며 파일 로딩에 실패합니다.

### 2\. 웹 서버의 절대 URL 경로 (Caution)

`http://mydomain.com/data/my_info.json` 또는 `/data/my_info.json`과 같은 웹 서버의 절대 URL 경로를 사용하는 경우입니다.

- **유연성 부족:** 만약 프로젝트가 `mydomain.com/portfolio/`와 같은 **서브 디렉터리**에 배포된다면, `/data/my_info.json`은 잘못된 경로(`mydomain.com/data/my_info.json`으로 해석됨)가 되어 파일 로딩에 실패합니다.
- **빌드 후 경로 관리 문제:** JSON 파일을 `src` 내부에서 `import`하는 방식(모듈 번들링)을 사용한다면, 배포 후에는 해당 파일이 별도의 URL로 존재하지 않고 최종 **번들 파일(JS 파일)** 안에 녹아들어 있습니다. 따라서 URL 경로로 접근하는 것 자체가 불가능합니다.

---

## ✅ 서버 배포 시 권장되는 2가지 방법

배포 환경에서 JSON 데이터를 안정적으로 불러오는 가장 좋은 방법은 JSON 파일을 **어떻게 처리했는지**에 따라 달라집니다.

### 1\. `src` 내부에 두고 `import` (가장 권장)

앞서 설명한 대로 JSON 파일을 `src/data`에 두고 `Info.tsx`에서 **상대 경로로 `import`** 하는 방식입니다.

- **작동 원리:** 이 방식은 빌드(Build) 과정에서 Webpack 등의 번들러가 JSON 내용을 읽어 해당 코드를 사용하는 JavaScript 파일 안에 **하드 코딩**하여 포함시킵니다.
- **결과:** 배포된 서버에서 JSON 파일 자체를 별도로 요청하지 않으며, **최종 JS 번들만 로드되면 데이터는 항상 존재**하므로 경로 문제에서 완전히 자유롭습니다.

<!-- end list -->

```tsx
// src/pages/info/Info.tsx (배포 후에도 동일하게 작동)
import myInfoData from "../../data/my_info.json";
// (myInfoData는 빌드 시 JS 번들에 포함됨)
```

### 2\. `public` 폴더에 두고 `fetch` (정적 파일 로딩 시)

JSON 파일을 **`public` 폴더**에 두고 `fetch` API로 불러오는 방식입니다.

- **작동 원리:** `public` 폴더의 파일은 빌드 시 수정 없이 그대로 복사되며, 배포 후 웹 서버의 루트 경로를 통해 **URL로 접근**할 수 있습니다.
- **결과:** 이 방식은 **경로를 상대적으로 설정**하거나, 프로젝트가 서브 디렉터리에 배포될 경우를 대비해 **환경 변수**를 사용하여 경로를 유연하게 설정해야 합니다.

<!-- end list -->

```tsx
// public 폴더에 파일이 있는 경우:
// 프로젝트의 기본 URL을 기준으로 요청
fetch("/my_info.json");
```

**결론적으로, JSON 데이터를 소스 코드의 일부로 간주하고 `src` 내부에 두고 상대 경로로 `import`하여 번들링하는 것이 배포 시 가장 안전하고 권장되는 방법입니다.**
